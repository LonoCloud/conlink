# A docker-compose file with an embedded network configuration
# and two docker containers that are connected via a switch and
# also serving as web servers with iplvan interfaces from the host
# that static NAT to the addresses where the web servers are bound.

version: "3.8"

services:
  network:
    build: {context: ../}
    image: conlink
    pid: host
    networks: []
    privileged: true  # required for *vlan creation in root ns
    security_opt: [ 'apparmor:unconfined' ] # needed on Ubuntu 18.04
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - /var/lib/docker:/var/lib/docker
      - ./:/test
    environment:
      - HOST_INTERFACE=${HOST_INTERFACE:?HOST_INTERFACE must be set}
      - NODE1_HOST_ADDRESS=${NODE1_HOST_ADDRESS:?NODE1_HOST_ADDRESS must be set}
      - NODE2_HOST_ADDRESS=${NODE2_HOST_ADDRESS:?NODE2_HOST_ADDRESS must be set}
      - NODE3_HOST_ADDRESS=${NODE3_HOST_ADDRESS:?NODE3_HOST_ADDRESS must be set}
    command: /sbin/conlink --compose-file /test/test9-compose.yaml

  node1:
    image: python:3-alpine
    cap_add: [NET_ADMIN]
    networks: []
    command: sh -c 'while ! ip link show eth0 up; do sleep 1; done;
                    python3 -m http.server --bind 10.0.1.2 81'

  node2:
    image: python:3-alpine
    cap_add: [NET_ADMIN]
    networks: []
    command: sh -c 'while ! ip link show eth0 up; do sleep 1; done;
                    python3 -m http.server --bind 10.0.2.2 82'

  node3:
    image: python:3-alpine
    cap_add: [NET_ADMIN]
    networks: []
    command: sh -c 'while ! ip link show eth0 up; do sleep 1; done;
                    python3 -m http.server --bind 10.0.3.2 83'

x-network:
  # "Physical" network interface definitions.
  # This defines container to container links.
  links:
    - left:  {container: node1_1,   intf:       eth0,  ip: 10.0.1.2/16}
      right: {container: network_1, intf: node1-eth0}
    - left:  {container: node2_1,   intf:       eth0,  ip: 10.0.2.2/16}
      right: {container: network_1, intf: node2-eth0}
    - left:  {container: node3_1,   intf:       eth0,  ip: 10.0.3.2/16}
      right: {container: network_1, intf: node3-eth0}

  interfaces:
    - {container: node1_1, intf: host, host-intf: "${HOST_INTERFACE}",
       type: macvlan, mode: bridge, ip: "${NODE1_HOST_ADDRESS}", nat: 10.0.1.2}
    - {container: node2_1, intf: host, host-intf: "${HOST_INTERFACE}",
       type: macvlan, mode: bridge, ip: "${NODE2_HOST_ADDRESS}", nat: 10.0.2.2}
    - {container: node3_1, intf: host, host-intf: "${HOST_INTERFACE}",
       type: vlan,    vlanid: 5,    ip: "${NODE3_HOST_ADDRESS}", nat: 10.0.3.2}

  # Network container mininet configuration
  # This configuration is used by config_mininet.py inside the network
  # container to define complex network elements (routers, switches,
  # etc).
  mininet-cfg:
    switches:
      - name: s1   # the switch between node1, node2, and node3
    interfaces:
      - name: node1-eth0
        node: s1
      - name: node2-eth0
        node: s1
      - name: node3-eth0
        node: s1
